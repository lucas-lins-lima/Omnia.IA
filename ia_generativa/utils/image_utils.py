"""
Image Utils - Funções utilitárias para processamento de imagens.
"""

import os
import numpy as np
from typing import Dict, List, Optional, Union, Any, Tuple
from PIL import Image, ImageDraw, ImageFont
import logging
import io
import base64
import time
import hashlib
import tempfile

logger = logging.getLogger(__name__)

def add_watermark(
    image: Image.Image,
    text: str = "Generated by Omnia.IA",
    position: str = "bottom",
    opacity: float = 0.5,
    font_size: int = 20,
    font_color: Tuple[int, int, int] = (255, 255, 255)
) -> Image.Image:
    """
    Adiciona uma marca d'água de texto a uma imagem.
    
    Args:
        image: Imagem para adicionar marca d'água
        text: Texto da marca d'água
        position: Posição ('top', 'bottom', 'center')
        opacity: Opacidade da marca d'água (0.0 a 1.0)
        font_size: Tamanho da fonte
        font_color: Cor do texto
        
    Returns:
        Imagem com marca d'água
    """
    # Criar uma cópia da imagem
    result = image.copy()
    
    # Criar uma camada para a marca d'água
    watermark = Image.new('RGBA', image.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(watermark)
    
    # Tentar carregar uma fonte
    try:
        # Tentativa de usar uma fonte padrão
        font = ImageFont.truetype("arial.ttf", font_size)
    except IOError:
        # Fallback para fonte padrão
        font = ImageFont.load_default()
    
    # Obter tamanho do texto
    text_width, text_height = draw.textsize(text, font=font)
    
    # Determinar posição
    width, height = image.size
    if position == "top":
        text_position = ((width - text_width) // 2, 10)
    elif position == "center":
        text_position = ((width - text_width) // 2, (height - text_height) // 2)
    else:  # bottom (default)
        text_position = ((width - text_width) // 2, height - text_height - 10)
    
    # Desenhar texto
    draw.text(text_position, text, font=font, fill=(*font_color, int(255 * opacity)))
    
    # Sobrepor marca d'água na imagem original
    return Image.alpha_composite(result.convert('RGBA'), watermark).convert('RGB')

def save_image_to_temp(
    image: Image.Image,
    format: str = "PNG",
    quality: int = 90,
    prefix: str = "omnia_"
) -> str:
    """
    Salva uma imagem em um arquivo temporário.
    
    Args:
        image: Imagem para salvar
        format: Formato da imagem (PNG, JPEG, etc.)
        quality: Qualidade para formatos com compressão
        prefix: Prefixo para o nome do arquivo
        
    Returns:
        Caminho para o arquivo temporário
    """
    # Gerar um identificador único baseado no timestamp e um hash
    timestamp = int(time.time() * 1000)
    hasher = hashlib.md5()
    hasher.update(f"{timestamp}_{np.random.randint(0, 1000000)}".encode('utf-8'))
    unique_id = hasher.hexdigest()[:12]
    
    # Criar arquivo temporário
    with tempfile.NamedTemporaryFile(suffix=f".{format.lower()}", prefix=f"{prefix}{unique_id}_", delete=False) as tmp:
        tmp_path = tmp.name
        
    # Salvar imagem
    image.save(tmp_path, format=format, quality=quality)
    logger.info(f"Imagem salva em arquivo temporário: {tmp_path}")
    
    return tmp_path

def create_image_grid(
    images: List[Image.Image],
    rows: Optional[int] = None,
    cols: Optional[int] = None,
    spacing: int = 10,
    background_color: Tuple[int, int, int] = (255, 255, 255)
) -> Image.Image:
    """
    Cria uma grade de imagens.
    
    Args:
        images: Lista de imagens para arranjar em grade
        rows: Número de linhas (determinado automaticamente se None)
        cols: Número de colunas (determinado automaticamente se None)
        spacing: Espaçamento entre as imagens em pixels
        background_color: Cor de fundo da grade
        
    Returns:
        Imagem composta com a grade de imagens
    """
    if not images:
        raise ValueError("A lista de imagens não pode estar vazia")
        
    num_images = len(images)
    
    # Determinar layout da grade
    if rows is None and cols is None:
        # Determinar automaticamente com base na raiz quadrada
        cols = int(np.ceil(np.sqrt(num_images)))
        rows = int(np.ceil(num_images / cols))
    elif rows is None:
        # Calcular linhas com base nas colunas
        rows = int(np.ceil(num_images / cols))
    elif cols is None:
        # Calcular colunas com base nas linhas
        cols = int(np.ceil(num_images / rows))
        
    # Obter as dimensões das imagens
    # Assumir que todas as imagens têm o mesmo tamanho
    img_width, img_height = images[0].size
    
    # Calcular dimensões da grade
    grid_width = cols * img_width + (cols - 1) * spacing
    grid_height = rows * img_height + (rows - 1) * spacing
    
    # Criar imagem para a grade
    grid = Image.new('RGB', (grid_width, grid_height), background_color)
    
    # Posicionar cada imagem na grade
    for i, img in enumerate(images):
        if i >= rows * cols:
            break  # Ignorar imagens extras
            
        # Calcular posição na grade
        row = i // cols
        col = i % cols
        
        x = col * (img_width + spacing)
        y = row * (img_height + spacing)
        
        # Colar imagem na grade
        grid.paste(img, (x, y))
        
    return grid
